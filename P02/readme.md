## توضیح خط‌به‌خط و Flow کد P02/main.go (درک عملی WaitGroup در Go)

این برنامه اندازه‌ی همه‌ی فایل‌های داخل مسیر `P02/tmp/files/` را به صورت همزمان (Concurrent) محاسبه می‌کند و در نهایت مجموع اندازه‌ها را چاپ می‌کند. برای همگام‌سازی اتمام گوروتین‌ها از `sync.WaitGroup` و برای حفاظت از جمع کل از `sync.Mutex` استفاده شده است. برای ساخت شناسه‌ی یکتا به شکل Thread-safe از `sync/atomic` استفاده می‌شود.

### خروجی نهایی چه کاری انجام می‌دهد؟
- همه‌ی فایل‌ها پیدا می‌شوند.
- برای هر فایل یک گوروتین جداگانه راه‌اندازی می‌شود.
- هر گوروتین اندازه‌ی فایل خودش را می‌خواند و به مجموع کل اضافه می‌کند.
- `main` تا تمام شدن همه‌ی گوروتین‌ها صبر می‌کند (`wg.Wait()`).
- در پایان «مجموع اندازه‌ی همه‌ی فایل‌ها» چاپ می‌شود.

---

### Flow کلی برنامه
- تنظیم فرمت لاگ‌ها با زمان و میکروثانیه‌ها.
- پیدا کردن مسیر فایل‌ها با `filepath.Glob`.
- تعریف متغیرهای اشتراکی: `totalSize`، قفل `mu`، `wg`، و شمارنده‌ی اتمی `nextID`.
- برای هر فایل:
  - تولید `jobID` یکتا با `atomic.AddInt64`.
  - `wg.Add(1)` و راه‌اندازی گوروتین.
  - داخل گوروتین: اندازه‌ی فایل محاسبه، سپس با قفل به جمع کل اضافه می‌شود، در انتها `wg.Done()`.
- بعد از راه‌اندازی همه‌ی گوروتین‌ها: `wg.Wait()` و سپس چاپ خروجی نهایی.

---

### توضیح خط‌به‌خط (با اشاره به شماره خطوط)

- L15: `log.SetFlags(log.Ltime | log.Lmicroseconds)`
  - تنظیم فرمت لاگ‌ها تا زمان و میکروثانیه نیز چاپ شوند؛ برای دنبال‌کردن دقیق‌تر Flow.

- L17–L29: اسکن مسیر فایل‌ها
  - `dir := "P02/tmp/files/"` تعیین دایرکتوری هدف.
  - `filepath.Glob(filepath.Join(dir, "*"))` تمام فایل‌های داخل مسیر را لیست می‌کند.
  - اگر خطا رخ دهد: `log.Fatalf` برنامه را با پیام خطا متوقف می‌کند.
  - اگر فایلی نبود: پیام مناسب و `return`.
  - در غیر این صورت تعداد فایل‌های پیدا شده لاگ می‌شود.

- L30–L35: تعریف متغیرهای اشتراکی و همگام‌سازی
  - `totalSize int64`: مجموع اندازه‌ی فایل‌ها (Shared State).
  - `mu sync.Mutex`: قفل برای محافظت از تغییر `totalSize`.
  - `wg sync.WaitGroup`: برای صبر کردن تا اتمام همه‌ی گوروتین‌ها.
  - `nextID int64`: شمارنده‌ی اتمی برای تخصیص شناسه‌ی یکتا به هر Job.

- L37–L71: حلقه‌ی راه‌اندازی گوروتین‌ها برای هر فایل
  - L38: `id := atomic.AddInt64(&nextID, 1)`
    - به صورت اتمی 1 واحد اضافه و مقدار جدید به عنوان `jobID` استفاده می‌شود (Thread-safe و بدون نیاز به Mutex).
  - L39: `path := f`
    - کپی محلی از مسیر فایل؛ از Capturing مستقیم متغیر حلقه اجتناب شده است (الگوی درست برای جلوگیری از باگ).
  - L41–L42: `wg.Add(1)`
    - قبل از راه‌اندازی گوروتین انجام می‌شود تا Race Condition در شمارش رخ ندهد.
  - L44–L70: راه‌اندازی گوروتین
    - L46–L49: `defer wg.Done()`
      - تضمین می‌کند در پایان کار گوروتین، شمارنده‌ی `wg` کم شود؛ حتی اگر خطایی رخ دهد یا `return` زودهنگام داشته باشیم.
    - L51: لاگ شروع پردازش فایل.
    - L53–L60: اندازه‌گیری زمان و خواندن اندازه‌ی فایل
      - `start := time.Now()` و سپس `getFileSize(jobID, p)`.
      - اگر خطا داشت: لاگ خطا و `return` (بدون تغییر جمع کل).
      - `elapsed := time.Since(start)` زمان سپری‌شده برای خواندن فایل.
    - L61: اعلام دریافت اندازه و رفتن برای گرفتن قفل.
    - L63–L67: بخش Critical با Mutex
      - `mu.Lock()` و سپس:
      - لاگ مقدار قبلی جمع، `totalSize += size`، لاگ مقدار جدید.
      - `mu.Unlock()` آزاد کردن قفل.
    - L69: اعلام اتمام بروزرسانی امن و اندازه‌ی فایل.

- L73–L79: انتظار تا اتمام همه‌ی کارها و خروجی نهایی
  - L73–L75: `wg.Wait()` بلوک می‌شود تا همه‌ی گوروتین‌ها `Done` را صدا بزنند.
  - L77: چاپ «Total size: ... bytes» به خروجی استاندارد.
  - L78–L79: لاگ خروج تمیز برنامه.

- L81–L97: تابع `getFileSize`
  - L82–L90: باز کردن فایل و `defer` برای بستن امن آن همراه با لاگ.
  - L92: یک `time.Sleep` کامنت‌شده که می‌توانید برای شبیه‌سازی I/O کند فعالش کنید.
  - L94–L96: `io.Copy(io.Discard, f)` کل محتوای فایل را می‌خواند اما جایی ذخیره نمی‌کند؛ فقط برای به‌دست آوردن تعداد بایت‌های خوانده‌شده است. مقدار بازگشتی `n` همان اندازه‌ی فایل محسوب می‌شود.

---

### چرا WaitGroup؟ چرا Mutex؟ چرا Atomic؟
- WaitGroup: چون برای هر فایل یک گوروتین داریم و `main` باید صبر کند تا همه تمام شوند. `wg.Add(1)` قبل از راه‌اندازی هر گوروتین و `wg.Done()` در پایان هر گوروتین صدا زده می‌شود؛ `wg.Wait()` تا صفر شدن شمارنده صبر می‌کند.
- Mutex روی `totalSize`: مقدار `totalSize` Shared است؛ بدون قفل امکان Race Condition وجود دارد. با `mu.Lock/Unlock` بخش Critical کوچک و امن شده است.
- Atomic برای `nextID`: تولید شناسه‌ی یکتا بدون نیاز به Mutex و با حداقل سربار.

### نکات مهم همزمانی (Best Practices)
- `wg.Add(1)` را همیشه قبل از `go` انجام دهید، نه داخل گوروتین.
- متغیرهای حلقه را به پارامترهای تابع گوروتین پاس دهید (مثل `jobID` و `p`) تا از Capturing اشتباه جلوگیری شود.
- در صورت به‌روزرسانی Shared State (مثل جمع کل)، از قفل یا Primitiveهای اتمی مناسب استفاده کنید.
- ترتیب لاگ‌ها تضمین‌شده نیست؛ چون گوروتین‌ها همزمان اجرا می‌شوند.

### اجرای برنامه
- پیش‌نیاز: وجود فایل‌ها در `P02/tmp/files/`.
- اجرا:

```bash
go run P02/main.go
```

نمونه‌ای از لاگ‌ها (ترتیب ممکن است متفاوت باشد):

```
[main] start. scanning dir="P02/tmp/files/"
[main] found 7 files
[main] wg.Add(1) for job=1 file=P02/tmp/files/file1.txt
[main] launching goroutine for job=1
...
[job 1] START processing file=...
[job 1] io.Copy done bytes=... err=<nil>
[job 1] LOCKED. total(before)=...
[job 1] updated total(after)=... → unlocking
...
[main] all goroutines launched → entering wg.Wait() (blocking)
[main] wg.Wait() returned (all jobs done)
Total size: 12345 bytes
[main] exit
```

### اگر بخواهید رفتار را ببینید/تغییر دهید
- برای مشاهده‌ی تأخیر و تفاوت‌های زمانی، خط L92 را از کامنت خارج کنید تا I/O کند شبیه‌سازی شود:
  - `time.Sleep(50 * time.Millisecond)`
- می‌توانید اندازه‌ی فایل‌ها یا تعدادشان را تغییر دهید تا اثر همزمانی روی ترتیب لاگ‌ها را بهتر ببینید.

---

### جمع‌بندی
- این کد نمونه‌ی ساده‌ای از الگوی رایج «Fan-out با گوروتین‌ها + هماهنگ‌سازی با WaitGroup + حفاظت از Shared State با Mutex» است.
- `WaitGroup` برای صبرکردن تا اتمام همه‌ی کارهای همزمان، `Mutex` برای جلوگیری از Race روی جمع کل، و `atomic` برای اختصاص شناسه‌ی یکتا به شکلی کارآمد استفاده شده‌اند.


