 ## توضیح خط‌به‌خط و Flow کدهای P03 (درک عملی Mutex و RWMutex در Go)

این پروژه دو پیاده‌سازی مختلف از شمارنده (Counter) را با استفاده از `sync.Mutex` و `sync.RWMutex` ارائه می‌دهد و تفاوت عملکرد و رفتار آن‌ها را در سناریوهای همزمانی (Concurrency) بررسی می‌کند. همچنین تست‌های واحد و بنچمارک برای مقایسه‌ی این دو مدل وجود دارد.

### خروجی نهایی چه کاری انجام می‌دهد؟
- شبیه‌سازی ۸ کاربر همزمان که هرکدام روی ۳ مسیر مختلف (path) عملیات انجام می‌دهند.
- هر کاربر ۱۰۰۰ بار یک مسیر را انتخاب و مقدار آن را افزایش می‌دهد و مقدار فعلی را می‌خواند.
- در پایان، Snapshot نهایی شمارنده‌ها چاپ می‌شود.

---

### Flow کلی برنامه (main.go)
- انتخاب نوع شمارنده: `CounterM` (با Mutex) یا `CounterRW` (با RWMutex).
- تعریف WaitGroup برای همگام‌سازی پایان کار گوروتین‌ها.
- راه‌اندازی ۸ گوروتین (کاربر همزمان):
  - هر گوروتین ۱۰۰۰ بار یک مسیر را انتخاب می‌کند (۳ مسیر مختلف: `/post/0`، `/post/1`، `/post/2`).
  - در هر تکرار: مقدار مسیر را افزایش می‌دهد (`Inc`) و مقدار فعلی را می‌خواند (`Get`).
  - بین هر عملیات ۱ میلی‌ثانیه تاخیر دارد.
- پس از اتمام همه گوروتین‌ها، Snapshot نهایی شمارنده چاپ می‌شود.

---

### توضیح خط‌به‌خط (با اشاره به شماره خطوط)

#### main.go
- L11: ساخت نمونه‌ی شمارنده با RWMutex (`NewCounterRW`). (برای تست Mutex کافیست خط 12 را فعال کنید)
- L14–L27: حلقه‌ی راه‌اندازی ۸ گوروتین (کاربر همزمان)
  - L17–L26: هر گوروتین:
    - L19: انتخاب مسیر بر اساس id (۳ مسیر مختلف)
    - L20–L24: ۱۰۰۰ بار افزایش مقدار و خواندن مقدار مسیر، با تاخیر ۱ms
    - L25: لاگ پایان کاربر
- L28: انتظار تا اتمام همه گوروتین‌ها (`wg.Wait()`)
- L30: چاپ Snapshot نهایی شمارنده

#### counter_mutex.go
- L5–L8: تعریف ساختار `CounterM` با Mutex و map
- L10–L12: سازنده‌ی شمارنده Mutex
- L14–L18: متد `Inc` (افزایش مقدار مسیر با قفل Mutex)
- L20–L25: متد `Get` (خواندن مقدار مسیر با قفل Mutex)
- L27–L35: متد `Snapshot` (کپی امن از map با قفل Mutex)

#### counter_rwmutex.go
- L5–L8: تعریف ساختار `CounterRW` با RWMutex و map
- L10–L12: سازنده‌ی شمارنده RWMutex
- L14–L18: متد `Inc` (افزایش مقدار مسیر با قفل نوشتن RWMutex)
- L20–L25: متد `Get` (خواندن مقدار مسیر با قفل خواندن RWMutex)
- L27–L35: متد `Snapshot` (کپی امن از map با قفل خواندن RWMutex)

---

### چرا Mutex؟ چرا RWMutex؟
- **Mutex**: هر عملیات (خواندن یا نوشتن) باید قفل را بگیرد؛ مناسب برای زمانی که تعداد عملیات نوشتن و خواندن تقریباً برابر است یا رقابت بالا نیست.
- **RWMutex**: عملیات خواندن می‌تواند همزمان توسط چند گوروتین انجام شود (تا زمانی که عملیات نوشتن نباشد)؛ مناسب برای سناریوهایی با خواندن زیاد و نوشتن کم (Read-heavy).

---

### تست‌ها (counter_test.go)
- تابع کمکی `runConcurrent`: ۱۰۰ گوروتین برای نوشتن و ۱۰۰ گوروتین برای خواندن همزمان روی یک مسیر راه‌اندازی می‌کند.
- `TestCounterM`: تست صحت عملکرد شمارنده Mutex
- `TestCounterRW`: تست صحت عملکرد شمارنده RWMutex
- هر تست بررسی می‌کند که مقدار نهایی مثبت باشد و Snapshot خالی نباشد.

---

### بنچمارک‌ها (bench_test.go)
- **Benchmark_ReadHeavy_Mutex**: سناریوی خواندن زیاد (۹۰٪ خواندن، ۱۰٪ نوشتن) با Mutex
- **Benchmark_ReadHeavy_RWMutex**: همان سناریو با RWMutex
- **Benchmark_WriteHeavy_Mutex**: سناریوی نوشتن سنگین (فقط نوشتن) با Mutex
- **Benchmark_WriteHeavy_RWMutex**: همان سناریو با RWMutex
- تابع کمکی `makeTestPaths`: تولید مسیرهای تست تصادفی

---

### جمع‌بندی
- این پروژه تفاوت عملی Mutex و RWMutex را در سناریوهای مختلف همزمانی و بارگذاری نشان می‌دهد.
- RWMutex در سناریوهای خواندن زیاد (Read-heavy) می‌تواند عملکرد بهتری نسبت به Mutex داشته باشد.
- تست‌ها و بنچمارک‌ها ابزار مناسبی برای مقایسه و تحلیل رفتار این دو مدل هستند.
